---
layout:     post
title:      "JVM调优参数详解"
subtitle:   "深入掌握JVM中各项参数的实际意义"
date:       2017-01-22
author:     "Chenyan"
header-img: "img/post-bg-rwd.jpg"
catalog:    true
tags:
    - Java virtual machines
---

## JVM参数

参数名称 | 含义 | 默认值 | &nbsp;
---|---
-Xms | 初始堆大小 | 初始堆大小 | 默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，<br/>JVM就会增大堆直到-Xmx的最大限制.
-Xmx | 最大堆大小 | 物理内存的1/4(<1GB) | 默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制
-Xmn | 年轻代大小(1.4or lator) | | 此处的大小是（eden+ 2 survivor space).与jmap -heap中显示的New gen是不同的。<br/>整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。<br />增大年轻代后,将会减小年老代大小。此值对系统性能影响较大,Sun官方推荐配置为整个堆的3/8
-XX:NewSize	| 设置年轻代大小(for 1.3/1.4) | |
-XX:MaxNewSize | 年轻代最大值(for 1.3/1.4) | | 
-XX:PermSize | 设置持久代(perm gen)初始值 | 物理内存的1/64 | |
-XX:MaxPermSize | 设置持久代最大值 | 物理内存的1/4 | |
-Xss | 每个线程的堆栈大小 | | JDK5.0以后每个线程堆栈大小为1M,以前每个线程堆栈大小为256K.更具应用的线程所需内存大小进行 调整.在相同物理内存下,减小这个值能生成更多的线程.但是操作系统对一个进程内的线程数还是有限制的,不能无限生成,经验值在3000~5000左右<br />一般小的应用， 如果栈不是很深， 应该是128k够用的 大的应用建议使用256k。这个选项对性能影响比较大，需要严格的测试。
-XX:ThreadStackSize	| Thread Stack Size |  |
-XX:NewRatio | 年轻代(包括Eden和两个Survivor区)与年老代的比值(除去持久代) | | -XX:NewRatio=4表示年轻代与年老代所占比值为1:4,年轻代占整个堆栈的1/5<br />Xms=Xmx并且设置了Xmn的情况下，该参数不需要进行设置
-XX:SurvivorRatio | Eden区与Survivor区的大小比值 | | 设置为8,则两个Survivor区与一个Eden区的比值为2:8,一个Survivor区占整个年轻代的1/10
-XX:LargePageSizeInBytes | 内存页的大小不可设置过大， 会影响Perm的大小 | | =128m
-XX:+UseFastAccessorMethods	| 原始类型的快速优化 | |
-XX:+DisableExplicitGC | 关闭System.gc() | | 这个参数需要严格的测试
-XX:MaxTenuringThreshold | 垃圾最大年龄 | |  如果设置为0的话,则年轻代对象不经过Survivor区,直接进入年老代. 对于年老代比较多的应用,可以提高效率.如果将此值设置为一个较大值,则年轻代对象会在Survivor区进行多次复制,这样可以增加对象再年轻代的存活 时间,增加在年轻代即被回收的概率，该参数只有在串行GC时才有效。
-XX:+AggressiveOpts | 加快编译 | |
-XX:+UseBiasedLocking | 锁机制的性能改善 | | 
-Xnoclassgc	| 禁用垃圾回收 | |
-XX:SoftRefLRUPolicyMSPerMB | 每兆堆空闲空间中SoftReference的存活时间 | 1s	| 
-XX:PretenureSizeThreshold	| 对象超过多大是直接在旧生代分配 | 0 | 单位字节 新生代采用Parallel Scavenge GC时无效，另一种直接在旧生代分配的情况是大的数组对象,且数组中无外部引用对象.
-XX:TLABWasteTargetPercent | TLAB占eden区的百分比 | 1% | 
-XX:+CollectGen0First | FullGC时是否先YGC | false |

## 并行收集器相关参数

参数名称 | 含义 | 默认值 | &nbsp;
---|---
-XX:+UseParallelGC | Full GC采用parallel MSC(此项待验证) | |  选择垃圾收集器为并行收集器.此配置仅对年轻代有效.即上述配置下,<br />年轻代使用并发收集,而年老代仍旧使用串行收集.(此项待验证)
-XX:+UseParNewGC | 设置年轻代为并行收集 | | 可与CMS收集同时使用<br />JDK5.0以上,JVM会根据系统配置自行设置,所以无需再设置此值
-XX:ParallelGCThreads | 并行收集器的线程数 | | 此值最好配置与处理器数目相等 同样适用于CMS
-XX:+UseParallelOldGC | 年老代垃圾收集方式为并行收集(Parallel Compacting) | |	这个是JAVA 6出现的参数选项
-XX:MaxGCPauseMillis | 每次年轻代垃圾回收的最长时间(最大暂停时间) | |	 	如果无法满足此时间,JVM会自动调整年轻代大小,以满足此值.
-XX:+UseAdaptiveSizePolicy | 自动选择年轻代区大小和相应的Survivor区比例 | |	 	设置此选项后,并行收集器会自动选择年轻代区大小和相应的Survivor区比例,<br />以达到目标系统规定的最低相应时间或者收集频率等,此值建议使用并行收集器时,一直打开.
-XX:GCTimeRatio | 设置垃圾回收时间占程序运行时间的百分比 | | 公式为1/(1+n)
-XX:+ScavengeBeforeFullGC | Full GC前调用YGC | true | Do young generation GC prior to a full GC. (Introduced in 1.4.1.)

## GC种类


类别 | serial collector | parallel collector | concurrent collector
---|---
介绍 | 单线程收集器<br/>使用单线程去完成所有的gc工作，没有线程间的通信，这种方式会相对高效 | 并行收集器<br/>使用多线程的方式，利用多CUP来提高GC的效率<br/>主要以到达一定的吞吐量为目标 | 并发收集器<br />使用多线程的方式,利用多CUP来提高GC的效率<br />并发完成大部分工作，使得gc pause短
试用场景 | 单处理器机器且没有pause time的要求 | 适用于科学技术和后台处理<br/>有中规模/大规模数据集大小的应用且运行在多处理器上，关注吞吐量(throughput) | 适合中规模/大规模数据集大小的应用，应用服务器,电信领域<br/>关注response time，而不是throughput
使用 | Client模式下默认<br/>可使用<br/>可用-XX:+UseSerialGC强制使用<br/>优点:对server应用没什么优点<br/>缺点:慢,不能充分发挥硬件资源 |Server模式下默认<br/>--YGC:PS FGC:Parallel MSC<br/>可用-XX:+UseParallelGC或-XX:+UseParallelOldGC强制指定<br/>--ParallelGC代表FGC为Parallel MSC<br/>--ParallelOldGC代表FGC为Parallel Compacting<br/>优点:高效<br/>缺点:当heap变大后,造成的暂停时间会变得比较长|可用-XX:+UseConcMarkSweepGC强制指定<br/>优点:<br/>对old进行回收时,对应用造成的暂停时间非常端,适合对latency要求比较高的应用<br/>缺点:<br/>1.内存碎片和浮动垃圾<br/>2.old去的内存分配效率低<br/>3.回收的整个耗时比较长<br/>4.和应用争抢CPU
内存回收触发 |**YGC**<br/>eden空间不足<br/>**FGC**<br/>old空间不足<br/>perm空间不足<br/>显示调用System.gc() ,包括RMI等的定时触发<br/>YGC时的悲观策略<br/>dump live的内存信息时(jmap –dump:live)|**YGC**<br/>eden空间不足<br/>**FGC**<br/>old空间不足<br/>perm空间不足<br/>显示调用System.gc() ,包括RMI等的定时触发<br/>YGC时的悲观策略--YGC前&YGC后<br/>dump live的内存信息时(jmap –dump:live)|**YGC**<br/>eden空间不足<br/>**CMS GC**<br/>1.old Gen的使用率大的一定的比率 默认为92%<br/>2.配置了CMSClassUnloadingEnabled,且Perm Gen的使用达到一定的比率 默认为92%<br/>3.Hotspot自己根据估计决定是否要触法<br/>4.在配置了ExplictGCInvokesConcurrent的情况下显示调用了System.gc.<br/>Full GC(Serial MSC)<br/>promotion failed 或 concurrent Mode Failure时
内存回收触发时发生了什么 |**YGC**<br/>清空eden+from中所有no ref的对象占用的内存<br/>将eden+from中的所有存活的对象copy到to中<br/>在这个过程中一些对象将晋升到old中:<br/>--to放不下的<br/>--存活次数超过tenuring threshold的<br/>重新计算Tenuring Threshold;<br/>单线程做以上动作<br/>全程暂停应用<br/>**FGC**<br/>如果配置了CollectGen0First,则先触发YGC<br/>清空heap中no ref的对象,permgen中已经被卸载的classloader中加载的class的信息<br/>单线程做以上动作<br/>全程暂停应用|**YGC**<br/>同serial动作基本相同,不同点:<br/>1.多线程处理<br/>2.YGC的最后不仅重新计算Tenuring Threshold,还会重新调整Eden和From的大小<br/>**FGC**<br/>1.如配置了ScavengeBeforeFullGC(默认),则先触发YGC<br/>2.MSC:清空heap中的no ref对象,permgen中已经被卸载的classloader中加载的class信息,并进行压缩<br/>3.Compacting:清空heap中部分no ref的对象,permgen中已经被卸载的classloader中加载的class信息,并进行部分压缩<br/>多线程做以上动作.|**YGC**<br/>同serial动作基本相同,不同点:<br/>1.多线程处理<br/>CMSGC:<br/>1.old gen到达比率时只清除old gen中no ref的对象所占用的空间<br/>2.perm gen到达比率时只清除已被清除的classloader加载的class信息<br/>**FGC**<br/>同serial
细节参数 |可用-XX:+UseSerialGC强制使用<br/>-XX:SurvivorRatio=x,控制eden/s0/s1的大小<br/>-XX:MaxTenuringThreshold,用于控制对象在新生代存活的最大次数<br/>-XX:PretenureSizeThreshold=x,控制超过多大的字节的对象就在old分配.|-XX:SurvivorRatio=x,控制eden/s0/s1的大小<br/>-XX:MaxTenuringThreshold,用于控制对象在新生代存活的最大次数<br/>-XX:UseAdaptiveSizePolicy 去掉YGC后动态调整eden from已经tenuringthreshold的动作<br/>-XX:ParallelGCThreads 设置并行的线程数|-XX:CMSInitiatingOccupancyFraction 设置old gen使用到达多少比率时触发<br/>-XX:CMSInitiatingPermOccupancyFraction,设置PermGen使用到达多少比率时触发<br/>-XX:+UseCMSInitiatingOccupancyOnly禁止hostspot自行触发CMS GC
 
## GC性能方面的考虑

 对于GC的性能主要有2个方面的指标：吞吐量throughput（工作时间不算gc的时间占总的时间比）和暂停pause（gc发生时app对外显示的无法响应）。

1. Total Heap

默认情况下，vm会增加/减少heap大小以维持free space在整个vm中占的比例，这个比例由MinHeapFreeRatio和MaxHeapFreeRatio指定。

一般而言，server端的app会有以下规则：

 - 对vm分配尽可能多的memory
 
 - 将Xms和Xmx设为一样的值。如果虚拟机启动时设置使用的内存比较小，这个时候又需要初始化很多对象，虚拟机就必须重复地增加内存。
 - 处理器核数增加，内存也跟着增大。
 
<span>2. The Young Generation</span>

另外一个对于app流畅性运行影响的因素是young generation的大小。young generation越大，minor collection越少；但是在固定heap size情况下，更大的young generation就意味着小的tenured generation，就意味着更多的major collection(major collection会引发minor collection)。

NewRatio反映的是young和tenured generation的大小比例。NewSize和MaxNewSize反映的是young generation大小的下限和上限，将这两个值设为一样就固定了young generation的大小（同Xms和Xmx设为一样）。

如果希望，SurvivorRatio也可以优化survivor的大小，不过这对于性能的影响不是很大。SurvivorRatio是eden和survior大小比例。

一般而言，server端的app会有以下规则：

 - 首先决定能分配给vm的最大的heap size，然后设定最佳的young generation的大小
 - 如果heap size固定后，增加young generation的大小意味着减小tenured generation大小。让tenured generation在任何时候够大，能够容纳所有live的data（留10%-20%的空余）。